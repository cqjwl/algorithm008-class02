# 学习笔记

## 动态规划：

### 递归：

将原问题拆分成具有相同性质的子问题；

递归的特点：
1、子问题拆分方程式，比如：f(n) = f(n-1) * n；
2、终止条件：也就是子问题无法再进一步拆分时，这时可以直接求出解，退出递归；

### 分治：

将原问题分解成多个子问题；

分治的特点：
1、分解：将原问题拆分成若干个子问题；
2、求解子问题：也就是终止条件；
3、合并：将各个子问题的解合并，形成原问题的解；

### 回溯：

按指定策略遍历所有可能路径的方法，在遍历的过程中，找出所有满足条件的解。每走一步，判断当前情况是否满足条件，若满足条件，则在该路径上继续试探，若不满足条件，则回溯（回退）至上一步，然后换一条路径继续试探；

回溯的特点：

1、定义解空间集：针对所给问题，定义问题的解空间；
2、遍历解空间集：以深度优先方式搜索解空间；
3、剪枝：在遍历解空间集的时候，用剪枝函数避免无效搜索，在扩展结点中剪去不满足约束的子树、剪去得不到最优解的子树；
4、加入元素：遍历空间集的时候，加入选择的元素，然后再进行搜索；
5、移除元素：当本轮搜索达到终止条件结束的时候，说明当前选择已经完成，需要返回到上一轮做其他选择，因此需要将上一轮选择时加入的元素删除掉；

### 动态规划：

与分治类似，也是将待求解的问题分解为若干个子问题，按顺序求解子问题，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

动态规划的特点：
1、最优子结构：在自下而上或自顶向下的记忆化递推过程中，求得的每个子问题一定是最优的局部解；
2、状态初始化：先初始化已知状态，从而才能自下而上的递推到原问题得解；
3、状态转移方程：从前一个子问题转化到后一个子问题之间的递推关系；

两个常用的剪枝函数：

约束函数：在扩展结点中剪去不满足约束的子树

### 代码模板：

```c
 //状态初始化
 for (i = 0; i <= n; i++) {
     dp[i] = 0;
 }

 //遍历解空间，计算每个子问题的局部最优解
 for (int i = 1; i <= n; i++) {
     for (int j = 1; j <= m; j++) {
         if (!condition1) {
             dp[i] = dp[i - 1];
         } else {
             dp[i] = max (或min)(dp[i - 1], dp[i - 1] + ... );
         }
    }
}

return dp[n];
```

### 代码实践：

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

dp[i, j]表示从左上角到坐标[i, j]的最小路径权值；递推公式：dp[i, j] = min (dp[i - 1, j], dp[i, j - 1]) + grid[i, j]；

需要注意最上一行和最左一列的dp值计算只有一个相邻值dp[i - 1, j]、dp[i, j - 1]参与计算；

```c
int minPathSum(int** grid, int gridSize, int* gridColSize){
    if (gridSize <= 0 || gridColSize[0] <= 0) {
        return 0;
    }

    int n = gridSize;
    int m = gridColSize[0];

    int dp[n][m];
    dp[0][0] = grid[0][0];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 && j == 0) {
                continue;
            }

            if (i == 0) {
                dp[i][j] = dp[i][j - 1] + grid[i][j];
            } else if (j == 0) {
                dp[i][j] = dp[i - 1][j] + grid[i][j];
            } else {
                dp[i][j] = fmin(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
    }

    return dp[n - 1][m - 1];
}
```

#### [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

dp[i)表示str[0...i]的译码方法总和；由于小写字母数最大为26；因此针对取2位数的值是否在26内，分别有不同递推公式：

dp[i] = dp[i - 1] 或 dp[i] = dp[i - 1] + dp[i - 2]；

```c
int numDecodings(char * s){
    if (s == NULL || s[0] == '0') {
        return 0;
    }

    int len = strlen(s);

    int dp[len];
    dp[0] = 1;
    int val = 0;
    if (len > 1) {
        if (s[1] == '0') {
            val = 10 * (s[0] - '0')+ s[1] - '0';
            if ( val <= 26) {
                dp[1] = 1;
            } else {
                return 0;
            }            
        }else {
            val = 10 * (s[0] - '0')+ s[1] - '0';
            if (val <= 26) {
                dp[1] = 2;
            } else {
                dp[1] = 1;
            }
        }
    } else {
        return 1;
    }

    for (int i = 2; i < len; i++) {
        if (s[i] == '0') {
            if (s[i - 1] == '0') {
                return 0;
            } else {
                val = 10 * (s[i - 1] - '0')+ s[i] - '0';
                if ( val <= 26) {
                    dp[i] = dp[i - 2];
                } else {
                    return 0;
                }                            
            }
        } else {
            if (s[i - 1] == '0') {
                dp[i] = dp[i - 1];
            } else {
                val = 10 * (s[i - 1] - '0')+ s[i] - '0';
                if ( val <= 26) {
                    dp[i] = dp[i - 1] + dp[i - 2];
                } else {
                    dp[i] = dp[i - 1];
                }                            
            }            
        }
    }

    return dp[len - 1];
}
```
